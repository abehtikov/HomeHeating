import org.openhab.core.library.types.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*
import java.util.Date
import org.joda.time.*
import java.lang.Math
import org.joda.time.Minutes

var double alpha = 0.15 // low pass filter tuning param
// RC = sampling_period * (1 - alpha) / alpha
// RC - time constant
// when alpha = 0.5, time constant is equal to the sampling_period
// alpha=0.15 --> 6 * sampling_period
// alpha=0.1  --> 9 * sampling_period

var double filteredValue = -99 // workaround for null

val int collectorAzimuthAngle = 234

var boolean pump_on = false
var Timer dhwDischargeTimer = null
var Timer solarManualOperationTimer = null

/******** Common diff. controller rules   */

rule "Temperature Sensor update"
when 
	//Item CollectorTemp received update or
	Item ReturnTemp received update
then
	if ((CollectorTemp.state instanceof DecimalType) && 
		(ReturnTemp.state instanceof DecimalType)) {
			
		var tColl = (CollectorTemp.state as DecimalType).doubleValue
		var tReturn = (ReturnTemp.state as DecimalType).doubleValue
	
		var tDelta = tColl - tReturn
	
		logDebug("solar", "Temperature drop is: {} K", tDelta)
	
		if (filteredValue == -99) {
			filteredValue = tDelta.doubleValue
		} else {
			filteredValue = filteredValue + alpha * (tDelta - filteredValue)
			val int vv = (filteredValue * 1000).intValue
			filteredValue = vv / 1000.0;
		}
		
		logDebug("solar.rules", "DeltaT after Low Pass filter (a={}) is: {} K", alpha, filteredValue)
		
		postUpdate(rtDeltaT, tDelta)
		postUpdate(rtFiltDeltaT, filteredValue)
		
	} else {
		logInfo("solar", "Either collector or return temperature is undefined.")
	}
end

rule "Return temperature changed"
when
	Item ReturnTemp changed
then
	val temp = (ReturnTemp.state as DecimalType).doubleValue
	if (SolarPumpSw.state == ON) {	
		postUpdate(LatestDhwReturnTemp, temp)
		
		// over heating protection
		if (HolidayModeSw.state == ON && SunnyTomorrow.state == ON) {
			if (temp < 50) {
				//postUpdate(DischargeDHWRequest, OFF)
				
			} else if (temp > 80) {
				postUpdate(DischargeDHWRequest, ON)
			}
		}  
		
		if (temp > 90) {
			// stop charging DHW storage
		}
	}
end

rule "Low pass Delta T update"
when 
	Item rtFiltDeltaT received update
then
	var deltaT = (rtFiltDeltaT.state as DecimalType).doubleValue
	var tColl = (CollectorTemp.state as DecimalType).doubleValue
	var deltaMax = (tnDeltaTon.state as DecimalType).doubleValue
	
	// logInfo("solar", "Execute DeltaT update. Current pump state is: " + SolarPumpSw.state)
	if (ManualOperation.state == ON) {
	
	} else if (CollectorInShadow.state == ON && DischargeDHWRequest == ON) {
		
		logDebug("solar", "Discharging DHW Boiler...")	
	} else {
		
		if (SolarPumpSw.state == ON) {
			
			var powerFactor = (rtPowerDensity.state as DecimalType).doubleValue
			var power = deltaT * powerFactor
			
			var tMinDrop = (tnDeltaToff.state as DecimalType).doubleValue
			if (deltaT < tMinDrop) {
				logInfo("solar", "delta T:{} C, delta T OFF: {} C --> switching solar pump OFF.", deltaT, tMinDrop)
				sendCommand(SolarPumpSw, OFF)
				postUpdate(rtCollectorPower, 0)
				
			} else {
				// update estimated collector power
				postUpdate(rtCollectorPower, power.intValue)
			}
			
			//assume that exactly 1 minute has passed since the previous calculation
			var inc_kwh = (power / 1000.0) / 60.0
			var prev = (kwhToday.state as DecimalType).doubleValue
			postUpdate(kwhToday, prev + inc_kwh) 
			
		// Pump is OFF	
		} else if ((HeatingSupportSw.state == OFF) && (DHW_Request.state == ON)) { // check the mode
			
			var latestDhwReturnTemp = (LatestDhwReturnTemp.state as DecimalType).doubleValue
			
			logDebug("solar", "coll: {} C, latest retrun: {} C, delta ON: {} C", 
				tColl, latestDhwReturnTemp, deltaMax.intValue
			)
			// Enable solar DHW
			var tDiff = tColl - latestDhwReturnTemp
			if (tDiff > deltaMax) {
				logInfo("solar", "T-diff between Collector & latest DHW return T: {} K."
					+ " --> Switching solar pump ON.", tDiff)
				sendCommand(SolarPumpSw, ON)
			}
		// Heating support
		} else if (HeatingSupportSw.state == ON) {
			var tMinUnderfloor = (tnTminHeatingSupport.state as DecimalType).doubleValue
			
			if (tColl > tMinUnderfloor + deltaMax) {
				logInfo("solar", "Switching solar pump to support underfloor heating. T coll: {} C", tColl)
				sendCommand(SolarPumpSw, ON)
			}
		}
	}
	logDebug("solar", "Heating support: {}, DHW request: {}", HeatingSupportSw.state, DHW_Request.state)
end	

rule "Solar Pump switches ON"
when 
	Item SolarPumpSw changed to ON
then
	// log pump start time
	pump_on = true
	postUpdate(PumpStatusON, 5)
	
	// avoid switching the pump off until the temperatures stabilize
	// Low pass filter on deltaT implements this use-case (prevents from switching OFF too early)
	/* 
	sendCommand(rtAllowTurnOffPump, OFF)
	pumpDeadbandTimer = createTimer(now.plusMinutes(9)) [|
		postUpdate(rtAllowTurnOffPump, ON)
	]
	*/
end

rule "Solar Pump switches OFF"
when 
	Item SolarPumpSw changed from ON to OFF
then
	// log pump shutdown
	pump_on = false
	
	// remember latest DHW return temperature
	if (HeatingSupportSw.state == OFF) {
		var tReturn = (ReturnTemp.state as DecimalType).doubleValue
		//var delta = (rtFiltDeltaT.state as DecimalType).doubleValue
		postUpdate(LatestDhwReturnTemp, tReturn /*- delta/2*/)
		postUpdate(PumpLatestOperation, new DateTimeType())
		
		logInfo("solar", "DHW return temperature: {} deg.", tReturn)
	}
	
	postUpdate(PumpStatusON, 0) // 0 == Pump OFF
	
end

rule "Pump operation hours"
when
	Time cron "45 */3 * * * ?"
then
	if (pump_on == true) {
		var state = TotalPumpOperatingHr.state
		if (state == Undefined || state == Uninitialized) {
			postUpdate(TotalPumpOperatingHr, 0)
		} else {
			val inc = 0.05 // 3 minutes = 0.05 hour
			var lastValue = (TotalPumpOperatingHr.state as DecimalType).doubleValue
			postUpdate(TotalPumpOperatingHr, lastValue + inc)
			
			lastValue = (PumpOperationTodayHr.state as DecimalType).doubleValue
			postUpdate(PumpOperationTodayHr, lastValue + inc)
		}
	}
end

rule "Reset daily meters"
when 
	Time is midnight
then
	var lastDay_kwh = (kwhToday.state as DecimalType).doubleValue
	postUpdate(kwhToday, 0)
	
	var month_kwh = (kwhThisMonth.state as DecimalType).doubleValue
	postUpdate(kwhThisMonth, month_kwh + lastDay_kwh)
	
	postUpdate(PumpOperationTodayHr, 0)
end

rule "Sun position update"
when
	Item SunAzimuth received update
then
	var azimuth = (SunAzimuth.state as DecimalType).intValue
	var elevation = (SunElevation.state as DecimalType).doubleValue
	
	val minAngle = collectorAzimuthAngle - 90
	val maxAngle = collectorAzimuthAngle + 90
	
	if (elevation < 0) {
		postUpdate(CollectorInShadow, ON)
	}
	// horizontal shadow criteria
	else if (azimuth > minAngle && azimuth < maxAngle) {
		postUpdate(CollectorInShadow, OFF)
		var int angleDiff = Math::abs(azimuth - collectorAzimuthAngle)
		postUpdate(SunbeamAngleToFacade, 90 - angleDiff)
	} else {
		postUpdate(CollectorInShadow, ON)
	}
end

rule "Collector shadow ON/OFF"
when 
	Item CollectorInShadow changed
then
	var azimuth = (SunAzimuth.state as DecimalType).intValue
	var elevation = (SunElevation.state as DecimalType).doubleValue
	
	if (previousState == ON) {
		logInfo("solar", "Collector goes out of shadow."
			+ " Sun azimuth: {}, altitude: {}", azimuth, elevation)
	
	} else if (previousState == OFF) {
		// check for DHW discharge option
		if (DischargeDHWRequest.state == ON) {
			logInfo("solar", "Starting up the pump to discharge DHW storage.")
			sendCommand(SolarPumpSw, ON)
			dhwDischargeTimer = createTimer(now.plusMinutes(150), [| // +2.5 h to cool down
				sendCommand(SolarPumpSw, OFF)
				postUpdate(DischargeDHWRequest, OFF)
				logInfo("solar", "Discharge DHW is over. Stop the pump.")
			])
		}
		
		postUpdate(SunbeamAngleToFacade, -1.0)
	}
end


/*  End of Common diff. controller rules */

rule "Update ThingSpeak Solar temperatures"
when
	Time cron "15 * * * * ?"
then
	val field1 = (CollectorTemp.state as DecimalType).doubleValue
	val field2 = (ReturnTemp.state as DecimalType).doubleValue
	var field3 = 0
	if (SolarPumpSw.state == ON) { field3 = 1 }
	val field4 = (rtFiltDeltaT.state as DecimalType).doubleValue
	// flowRate
	val f5 = (pFlowRate.state as DecimalType).doubleValue
	val f6 = (LatestDhwReturnTemp.state as DecimalType).doubleValue
	
	val api_key = "4ZYKQYVC6E4WYELM"
	var url = String::format("https://api.thingspeak.com/update?"
		+ "api_key=%7$s"
		+ "&field1=%1$.2f"
		+ "&field2=%2$.2f"
		+ "&field3=%3$d"
		+ "&field4=%4$.2f"
		+ "&field5=%5$.1f"
		+ "&field6=%6$.1f",
		field1, field2, field3, field4, f5, f6, api_key
	)
	logDebug("solar", "Update thingspeak channel 61471: " + url)
	sendHttpGetRequest(url)
end	

/*
rule "Startup"
when
	System started
then	
	callScript("init_solar")
end
*/

rule "Update power density" // Удельная мощность теплоносителя Ватт/градус К
when
	Item pHeatingCapacity received update or
	Item pFlowRate received update
then
	var double value = 60.0 //by default 60 W/deg C
	
	if (pHeatingCapacity.state instanceof DecimalType &&
		pFlowRate.state instanceof DecimalType) {
		
		val capacity = (pHeatingCapacity.state as DecimalType).doubleValue
		val flowRate = (pFlowRate.state as DecimalType).doubleValue
		
		if (capacity > 3500.0 && capacity < 4200.0) {
			value = (capacity * flowRate / 3600.0).doubleValue
			logInfo("solar", "Power density: {} W/deg C, Flow rate: {} l/h", value, flowRate)
		} else {
			logWarn("solar", "Invalid heating capacity value: {}", capacity)
		}
	}
	
	postUpdate(rtPowerDensity, value)
end

/*
 * Если не в отпуске
 * и (а) коллектор находится в тени или
 * (б) нет солнца (пасмурно)
 * 
 * Само-остывание бойлера 1 кВт-ч/сутки + 6 кВт-ч/сутки потребление ГВ
 * 
 * Бойлер 120 лтр
 */
rule "DHW Storage self discharge" // 
when
	Time cron "0 */20 * * * ?" // every 20 min
then
	val oldValue = (LatestDhwReturnTemp.state as DecimalType).doubleValue
	var double k
	val double minTemp = 18.0
	
	// Коллектор в тени и насос выключен
	if (CollectorInShadow.state == ON && SolarPumpSw.state == OFF) {
		
		val delta = oldValue - minTemp
		if (HolidayModeSw.state == OFF) { // в обычное время
			k = 0.04
		} else { // нет водоразбора (в отпуске)
			k = 0.01
		}
		if (oldValue > 20.0) {
			// T бойлера не может упасть ниже 10 градусов (зимой - ниже 5)
			logInfo("solar", "DHW storage T {} down by {} C. Holiday mode: {}",
				oldValue, k * delta, HolidayModeSw.state
			)
			postUpdate(LatestDhwReturnTemp, oldValue - (k * delta))		
		}
	}
end

rule "Update Low Pass Filter"
when
	Item tnLowPassAlpha received update
then
	val double value = (tnLowPassAlpha.state as DecimalType).doubleValue
	
	if (value >= 0.05 && value <= 0.3) {
		logInfo("solar", "Low pass filter alpha updated from {} to {}", alpha, value)
		alpha = value
	}
end

rule "SolarPump control manual"
when 
	Item ManualOperation changed from OFF to ON
then
	if (solarManualOperationTimer != null) {
		solarManualOperationTimer.cancel()
		solarManualOperationTimer = null
	}
	// 15 min * 1100 W = 275 Wh = 237 kCall (2.37 kg water * 100 deltaT)
	// we can easily boil water inside the collector if we stop the pump for 15 min. 
	solarManualOperationTimer = createTimer(now.plusMinutes(15), [|
		sendCommand(ManualOperation, OFF)
	])
end	

rule "Weather forecast next day"
when 
	Item Clouds received update or
	Item Condition received update
then
	var cloudsPercent = (Clouds.state as DecimalType).intValue

	if (Condition.state == "clear sky") {
		postUpdate(SunnyTomorrow, ON)
	} else if (cloudsPercent > 60) {
		postUpdate(SunnyTomorrow, OFF)
	} else {
		postUpdate(SunnyTomorrow, ON)
	}
end

