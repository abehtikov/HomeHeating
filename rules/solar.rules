import org.openhab.core.library.types.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*
import java.util.Date
import org.joda.time.*
import java.lang.Math
import org.joda.time.Minutes

var double alpha = 0.25 // low pass filter tuning param
// RC = sampling_period * (1 - alpha) / alpha
// RC - time constant
// when alpha = 0.5, time constant is equal to the sampling_period
// alpha=0.15 --> 6 * sampling_period
// alpha=0.1  --> 9 * sampling_period

var double filteredValue = -99 // workaround for null

val int dischargeRequestTresholdTemp = 70
var double dhwMaxToday = 0

var boolean pump_on = false
var Timer dhwDischargeTimer = null
var Timer solarManualOperationTimer = null
var Timer iceProtectTimer = null

// discharged kWh counter
var double dischargeKWH = 0
var double dischargeKwhMin

/******** Common diff. controller rules   */

rule "Temperature Sensor update"
when 
	//Item CollectorTemp received update or
	Item ReturnTemp received update
then
	if ((CollectorTemp.state instanceof DecimalType) && 
		(ReturnTemp.state instanceof DecimalType)) {
			
		var tColl = (CollectorTemp.state as DecimalType).doubleValue
		var tReturn = (ReturnTemp.state as DecimalType).doubleValue
	
		var tDelta = tColl - tReturn
		
		// ignore return T when solar pump is OFF
		if (SolarPumpSw.state == OFF) { 
			val lastDhwTemp = (LatestDhwReturnTemp.state as DecimalType).doubleValue
			tDelta = tColl - lastDhwTemp
			
		} else if (SolarPumpSw.state == ON && rtControllerStatus.state != "FRP") {
			// CHARGE or DISCHARGE mode only
			postUpdate(LatestDhwReturnTemp, tReturn)
			
			// record maximum dhw T today
			if (tReturn > dhwMaxToday) {
				dhwMaxToday = tReturn
			}
		}
		
		logDebug("solar", "Temperature drop is: {} K", tDelta)
	
		if (filteredValue == -99) {
			filteredValue = tDelta.doubleValue
		} else {
			filteredValue = filteredValue + alpha * (tDelta - filteredValue)
			val int vv = (filteredValue * 1000).intValue
			filteredValue = vv / 1000.0;
		}
		
		logDebug("solar.rules", "DeltaT after Low Pass filter (a={}) is: {} K", alpha, filteredValue)
		
		postUpdate(rtDeltaT, tDelta)
		postUpdate(rtFiltDeltaT, filteredValue)
		
		
		
	} else {
		logInfo("solar", "Either collector or return temperature is undefined.")
	}
end

/*
rule "Return temperature changed"
when
	Item ReturnTemp changed
then
	val temp = (ReturnTemp.state as DecimalType).doubleValue
	if (SolarPumpSw.state == ON) {	
		postUpdate(LatestDhwReturnTemp, temp)
		
		// over heating protection
		if (HolidayModeSw.state == ON && SunnyTomorrow.state == ON) {
			if (temp < 50) {
				//postUpdate(DischargeDHWRequest, OFF)
				
			} else if (temp > dischargeRequestTresholdTemp) {
				postUpdate(DischargeDHWRequest, ON)
			}
		}  
		
		if (temp > 85) {
			// stop charging DHW storage to avoid damage
		}
	}
end
*/

rule "Low pass Delta T update"
when 
	Item rtFiltDeltaT received update
then
	var deltaT = (rtFiltDeltaT.state as DecimalType).doubleValue
	var tColl = (CollectorTemp.state as DecimalType).doubleValue
	var deltaMax = (tnDeltaTon.state as DecimalType).doubleValue
	val appState = rtControllerStatus.state
	
	// logInfo("solar", "Execute DeltaT update. Current pump state is: " + SolarPumpSw.state)
	if (ManualOperation.state == ON) {
		
	} else if (appState == "FRP") {
		logDebug("solar", "ICE protection of collector is enabled.")
	
	//} else if (CollectorInShadow.state == ON && DischargeDHWRequest == ON) {	
	} else if (appState == "DIS") {
		
		var powerFactor = (rtPowerDensity.state as DecimalType).doubleValue
		var power = deltaT * powerFactor
		var delta_kwh = (power / 1000.0) / 60.0
		
		dischargeKWH = (dischargeKWH - delta_kwh).doubleValue
		logDebug("solar", "Discharging DHW Boiler... {} kWh", dischargeKWH)
		dischargeKwhMin = (tnDischargeKwhMin.state as DecimalType).doubleValue
		
		var String reason = null
		if (dischargeKWH > dischargeKwhMin) {
			reason = "discharge amount is achieved"
		} else if (power > -100 && power < 0) {
			// delta is to low for discharge
			reason = "delta T is too low"
		}
		
		if (reason != null) {
			if (dhwDischargeTimer != null) { //disable timer in case we discharge faster than 2.5 h
				dhwDischargeTimer.cancel()
			}
			logInfo("solar", "Stop DHW discharge. Reason: {}", reason)
			sendCommand(rtControllerStatus, "IDLE")
		}
	} else if (appState == "OVP") {
		
	} else { // appState == IDLE || appState == CH
		
		if (SolarPumpSw.state == ON) {
			
			var powerFactor = (rtPowerDensity.state as DecimalType).doubleValue
			var power = deltaT * powerFactor
			
			var tMinDrop = (tnDeltaToff.state as DecimalType).doubleValue
			if (deltaT < tMinDrop) {
				logInfo("solar", "delta T:{} C, delta T OFF: {} C --> switching solar pump OFF.", deltaT, tMinDrop)
				sendCommand(SolarPumpSw, OFF)
				sendCommand(rtControllerStatus, "IDLE")
				postUpdate(rtCollectorPower, 0)
				
			} else {
				// update estimated collector power
				postUpdate(rtCollectorPower, power.intValue)
			}
			
			//assume that exactly 1 minute has passed since the previous calculation
			var inc_kwh = (power / 1000.0) / 60.0
			var prev = (kwhToday.state as DecimalType).doubleValue
			postUpdate(kwhToday, prev + inc_kwh) 
			
		// Pump is OFF	
		} else if ((HeatingSupportSw.state == OFF) && (DHW_Request.state == ON)) { // check the mode
			
			var latestDhwReturnTemp = (LatestDhwReturnTemp.state as DecimalType).doubleValue
			
			// Enable solar DHW
			var tDiff = tColl - latestDhwReturnTemp
			if (tDiff > deltaMax) {
				
				logInfo("solar", "T collector: {} C, T return: {} C, deltaT ON: {} C.", 
					tColl, latestDhwReturnTemp, deltaMax.intValue
				)
				logInfo("solar", "T-diff: {} K --> Switching solar pump ON.", tDiff)
				sendCommand(SolarPumpSw, ON)
				sendCommand(rtControllerStatus, "CH")
			}
		// Heating support
		} else if (HeatingSupportSw.state == ON) {
			var tMinUnderfloor = (tnTminHeatingSupport.state as DecimalType).doubleValue
			
			if (tColl > tMinUnderfloor + deltaMax) {
				logInfo("solar", "Switching solar pump to support underfloor heating. T coll: {} C", tColl)
				sendCommand(SolarPumpSw, ON)
				sendCommand(rtControllerStatus, "CH")
			}
		}
	}
	logDebug("solar", "Heating support: {}, DHW request: {}", HeatingSupportSw.state, DHW_Request.state)
end	

rule "Solar Pump switches ON"
when 
	Item SolarPumpSw changed to ON
then
	// log pump start time
	pump_on = true
	postUpdate(PumpStatusON, 5)
	
	// avoid switching the pump off until the temperatures stabilize
	// Low pass filter on deltaT implements this use-case (prevents from switching OFF too early)
	/* 
	sendCommand(rtAllowTurnOffPump, OFF)
	pumpDeadbandTimer = createTimer(now.plusMinutes(9)) [|
		postUpdate(rtAllowTurnOffPump, ON)
	]
	*/
end

rule "Solar Pump switches OFF"
when 
	Item SolarPumpSw changed from ON to OFF
then
	// log pump shutdown
	pump_on = false
	
	// remember latest DHW return temperature
	if (HeatingSupportSw.state == OFF) {
		var tReturn = (ReturnTemp.state as DecimalType).doubleValue
		//var delta = (rtFiltDeltaT.state as DecimalType).doubleValue
		postUpdate(LatestDhwReturnTemp, tReturn /*- delta/2*/)
		postUpdate(PumpLatestOperation, new DateTimeType())
		
		logInfo("solar", "DHW return temperature: {} deg.", tReturn)
	}
	
	postUpdate(PumpStatusON, 0) // 0 == Pump OFF
	
end

rule "Pump operation hours"
when
	Time cron "45 */3 * * * ?"
then
	if (pump_on == true) {
		var state = TotalPumpOperatingHr.state
		if (state == Undefined || state == Uninitialized) {
			postUpdate(TotalPumpOperatingHr, 0)
		} else {
			val inc = 0.05 // 3 minutes = 0.05 hour
			var lastValue = (TotalPumpOperatingHr.state as DecimalType).doubleValue
			postUpdate(TotalPumpOperatingHr, lastValue + inc)
			
			lastValue = (PumpOperationTodayHr.state as DecimalType).doubleValue
			postUpdate(PumpOperationTodayHr, lastValue + inc)
		}
	}
end

rule "Reset daily meters"
when 
	Time is midnight
then
	var lastDay_kwh = (kwhToday.state as DecimalType).doubleValue
	postUpdate(kwhToday, 0)
	
	var month_kwh = (kwhThisMonth.state as DecimalType).doubleValue
	postUpdate(kwhThisMonth, month_kwh + lastDay_kwh)
	
	postUpdate(PumpOperationTodayHr, 0)

	//check for possible discharge next morning 
	if (lastDay_kwh > 3 && dhwMaxToday > dischargeRequestTresholdTemp) {
		postUpdate(DischargeDHWRequest, ON)
	}
	dhwMaxToday = 0
end

rule "DHW charge percent"
when
	Item kwhToday received update
then
	val amount = (kwhToday.state as DecimalType).doubleValue
	val demand = (DhwDailyDemand.state as DecimalType).doubleValue
	
	if (amount > 0) {
		var int percent = (100 * amount / demand).intValue
		postUpdate(DhwChargeToday, percent)
	} else {
		postUpdate(DhwChargeToday, 0)
	}
end

/*
 * GUI solar controller params
 */
rule "Update power density" // Удельная мощность теплоносителя Ватт/градус К
when
	Item pHeatingCapacity received update or
	Item pFlowRate received update
then
	var double value = 60.0 //by default 60 W/deg C
	
	if (pHeatingCapacity.state instanceof DecimalType &&
		pFlowRate.state instanceof DecimalType) {
		
		val capacity = (pHeatingCapacity.state as DecimalType).doubleValue
		val flowRate = (pFlowRate.state as DecimalType).doubleValue
		
		if (capacity > 3500.0 && capacity < 4200.0) {
			value = (capacity * flowRate / 3600.0).doubleValue
			logInfo("solar", "Power density: {} W/deg C @ flow rate: {} l/h", value, flowRate)
		} else {
			logWarn("solar", "Invalid heating capacity value: {}", capacity)
		}
	
		postUpdate(rtPowerDensity, value)
	}
end

rule "Collector shadow ON/OFF"
when 
	Item CollectorInShadow changed
then
	var azimuth = (SunAzimuth.state as DecimalType).intValue
	var elevation = (SunElevation.state as DecimalType).doubleValue
	
	if (previousState == ON) {
		logInfo("solar", "Collector goes out of shadow."
			+ " Sun azimuth: {}, altitude: {}", azimuth, elevation)
	
	} else if (previousState == OFF) {

		postUpdate(SunbeamAngleToFacade, -1.0)
	}
end

/*
rule "Fire discharge Request"
when 
	Item DischargeDHWRequest changed from OFF to ON
then
	val temp = (LatestDhwReturnTemp.state as DecimalType).doubleValue
	logInfo("solar", "High return temperature observed: {} C. Request DHW boiler discharge.", temp)
end
*/

rule "Discharge timer 7am"
when
	Time cron "0 0 7 * * ?"
then
	if (HolidayModeSw.state == ON && SunnyTomorrow.state == ON) {
		if (DischargeDHWRequest.state == ON) {
			logInfo("solar", "Starting up the pump to discharge DHW storage.")
			sendCommand(rtControllerStatus, "DIS")
			sendCommand(SolarPumpSw, ON)
			// get config parameter of discharge duration
			val duration = (tnDischargeHrMin.state as DecimalType).doubleValue
			var int minutes = (duration * 60).intValue
			if (minutes < 1) {minutes = 5}
			dhwDischargeTimer = createTimer(now.plusMinutes(minutes), [| // +2.5 h to cool down
				sendCommand(rtControllerStatus, "IDLE")
			])
		}	
	}
end

/*  End of Common diff. controller rules */



rule "Update Low Pass Filter"
when
	Item tnLowPassAlpha received update
then
	val double value = (tnLowPassAlpha.state as DecimalType).doubleValue
	
	if (value >= 0.05 && value <= 0.3) {
		logInfo("solar", "Low pass filter alpha updated from {} to {}", alpha, value)
		alpha = value
	}
end


rule "SolarPump control manual"
when 
	Item ManualOperation changed from OFF to ON
then
	if (solarManualOperationTimer != null) {
		solarManualOperationTimer.cancel()
		solarManualOperationTimer = null
	}
	// 15 min * 1100 W = 275 Wh = 237 kCall (2.37 kg water * 100 deltaT)
	// we can easily boil water inside the collector if we stop the pump for 15 min. 
	solarManualOperationTimer = createTimer(now.plusMinutes(15), [|
		sendCommand(ManualOperation, OFF)
	])
end	


rule "Check collector T"
when
	Time cron "35 */10 * * * ?" // check every 10 minutes
then
	val tColl = (CollectorTemp.state as DecimalType).doubleValue
	val tReturn = (ReturnTemp.state as DecimalType).doubleValue
	val appState = rtControllerStatus.state
	
	if (tnIceProtectionEnabled.state == ON && SolarPumpSw.state == OFF) {
		
		var tempSP = (tnIceProtectionTMin.state as DecimalType).doubleValue
		if (tempSP < 1) {tempSP = 2.0}
		
		if (tColl < tempSP) {
			sendCommand(rtControllerStatus, "FRP")
			logInfo("solar", "Collector temperature: {} C. ICE protection activated.", tColl)
			sendCommand(SolarPumpSw, ON)
			
			val systemVolume = (pSystemVolume.state as DecimalType).doubleValue
			val flowRate = (pFlowRate.state as DecimalType).doubleValue
			
			var min = (30.0 * systemVolume / flowRate).intValue
			if (min < 4) { min = 4 }
			iceProtectTimer = createTimer(now.plusMinutes(min), [|
				sendCommand(SolarPumpSw, OFF)
				sendCommand(rtControllerStatus, "IDLE")
			])
		}
	}
	
	val tMax = (tnOverheatingTmax.state as DecimalType).doubleValue
	val tMin = (tnOverheatingTmin.state as DecimalType).doubleValue
	
	if (appState == "CH") {

		if (tReturn > tMax) {
			// DHW storage overheating protection
			sendCommand(rtControllerStatus, "OVP")
			sendCommand(SolarPumpSw, OFF)
		
			// notify user about possible collector stagnation
		}
	}
	
	if (appState == "OVP" && tColl < tMin) {
		sendCommand(rtControllerStatus, "IDLE")
	}
end


rule "Controller state changed"
when
	Item rtControllerStatus changed
then
	var appState = rtControllerStatus.state
	logInfo("solar", "Controller status CHANGED from {} to {}", 
		previousState, appState
	)
	
	if (previousState == "DIS" && appState == "IDLE") {
		logInfo("solar", "Discharge DHW finished event handled here.")
	}
end


rule "Discharge DHW is finished"
when
	Item rtControllerStatus changed from DIS to IDLE
then
	sendCommand(DischargeDHWRequest, OFF)
	
	val int vv = (dischargeKWH * 100).intValue
	logInfo("solar", "DHW discharged: {} kWh. Stop the pump.", vv / 100.0)
	
	sendCommand(SolarPumpSw, OFF)
	dischargeKWH = 0
	dhwDischargeTimer = null
end

