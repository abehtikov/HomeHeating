import org.openhab.core.library.types.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*
import java.util.Date
import org.joda.time.*
import java.lang.Math

var Number processUpdate = 0
//var String Boiler_PrevState
var String os_type = "linux" //"win"
var Timer timer = null
var Timer heatingBackToAuto = null
var Timer warmFloorTimer = null

val DateTimeType expired = new DateTimeType()

var Number t_fio24h = 0
var Number t_fio48h = 0
var Number t_owm24h = 0
// counters
var int c1 = 0
var int c2 = 0

rule "Calculate current heating power demand"
when
	//Item HeatLoadFactor changed or
	//Item HeatCompensation changed or
	Item ma48hRrdTemp changed
then
	var lf = (HeatLoadFactor.state as DecimalType).doubleValue
	var ambTemp 
	if (ma48hRrdTemp.state instanceof DecimalType) {
		ambTemp = (ma48hRrdTemp.state as DecimalType).doubleValue
	} else {
		ambTemp = (MonthAverageTemp.state as DecimalType).doubleValue
	}
	
	var roomTempAvg = (TempSensor.state as DecimalType).doubleValue
	var hc = (HeatCompensation.state as DecimalType).doubleValue
	var demand = (roomTempAvg - ambTemp) * lf - hc

	// Maximum required heat demand is 3kW (@-20C ambient temperature)
	if (demand > 3000) {
		demand = 3000
	}
	logDebug("brodok.rules", "calculated power demand kW: " + demand/1000)
	if (processUpdate == 1) {
		//postUpdate(HeatPowerDemand_Current, (demand/1000))	
		//postUpdate(PowerDemandLastUpdate, new DateTimeType())
		//HeatPowerDemand_Current.postUpdate(demand/1000)
		postUpdate(HeatPowerDemand_DailyAvg, demand/1000)
		PowerDemandLastUpdate.postUpdate(new DateTimeType())
	}
end

rule "Startup"
when
	System started
then
	
	postUpdate(TempSensor_Corridor, 20.0)
	postUpdate(TempSensor_Kitchen, 21.0)
	postUpdate(TempSensor_Bedroom, 19.0)
	
	AfterStartup.sendCommand(OFF)
	timer = createTimer(now.plusSeconds(20)) [|
		postUpdate(AfterStartup, ON)
	]
	//TempSensor.postUpdate(20.0)
	CalendarRequestPriority.postUpdate(ON)
	//BoilerCtrlMode.postUpdate("Calendar")
	
	//var os = java::lang::System::getProperty("os.name")
	//logDebug("homeHeating.os", os)
	
	logDebug("brodok.rules", "Init completed")
	processUpdate = 1
end	

/*
 * Let variables to get initial states from rrd
 */
rule "After System startup"
when
	Item AfterStartup changed from OFF to ON
then
	if (timer!=null) {
		timer.cancel
		timer = null
	}
	callScript("initialize")
	
	// after system reboot boiler control mode is restored back to calendar
	postUpdate(UserHeatingRequest, "AUTO")
	var String message = "Boiler control mode set to Calendar after system reboot"
	logInfo("heating.control.mode", message)
	// sendMail(to, subject, message)
end

rule "Convert Atm. Pressure units"
when
	Item AtmPressure_mbar changed
then
	var mbar = (AtmPressure_mbar.state as DecimalType).doubleValue
	var mmHg = mbar * 0.75006375541921
	postUpdate(AtmPressure_mmHg, mmHg.intValue)
end

rule "New month begins"
when
	Time cron "0 0 0 1 * ?" or 
	System started
then
	callScript("monthAverage")
end


/*
 * Deprecated
 *
rule "Heating Power demand persist to Google"
when
	Item ma24hTemp received update
then
	val t24ma = (ma24hTemp.state as DecimalType).doubleValue
	val t48ma = (ma48hTemp.state as DecimalType).doubleValue
	
	var t24avg = (ma24hRrdTemp.state as DecimalType).doubleValue
	var t48avg = (ma48hRrdTemp.state as DecimalType).doubleValue
	logInfo("gss.ma.temperature", "Moving average since 24/48 h is {}/{}", t24ma, t48ma)
	logInfo("gss.rrd.average.temp", "RRD based average temperature since 24/48 h is {}/{}", t24avg, t48avg)
	
	var Number dailyAvgAmbientTemp = t48avg
	
	var roomTempAvg = 16.0
	if (TempSensor.state instanceof DecimalType) {
		roomTempAvg = (TempSensor.state as DecimalType).doubleValue	
	}
	logDebug("gss.room.temp", "" + roomTempAvg)
	
	var hc = (HeatCompensation.state as DecimalType).intValue
	var lf = (HeatLoadFactor.state as DecimalType).intValue
	
	var demand = (roomTempAvg - dailyAvgAmbientTemp) * lf - hc

	// Maximum required heat demand is 3kW (@-20C ambient temperature)
	if (demand > 3000) {
		demand = 3000
	}
	demand = demand / 1000 // in kW
	logDebug("gss.daily.power.demand", demand + " kW")
	postUpdate(HeatPowerDemand_DailyAvg, demand)
	
	// run script to calculate boiler duty cycles according to the model
	callScript("demo")
	
	logDebug("gss.url", "" + GoogleScriptURL.state)
	
	val all40c = (Duration_ALL_40C.state as DecimalType).doubleValue
	val r70c = (Duration_R_70C.state as DecimalType).doubleValue
	val r40c = (Duration_R_40C.state as DecimalType).doubleValue
	
	val String url = GoogleScriptURL.state
	
	var winCurlCmd = String::format("cmd.exe /c curl -k \"%1$s?" +
		"Timestamp=%2$tQ&PowerDemand=%3$.3f&all40=%4$.3f&r70=%5$.3f&r40=%6$.3f\"",
		url, new Date(), demand, all40c, r70c, r40c)

	var curlCommand = String::format("/usr/bin/curl -k \"%1$s?" +
		"Timestamp=%2$tQ&PowerDemand=%3$.3f&all40=%4$.3f&r70=%5$.3f&r40=%6$.3f\"",
		url, new Date(), demand, all40c, r70c, r40c
	)
	
	if (os_type == "win") {
		logDebug("gss.win.curl", winCurlCmd)
		//executeCommandLine("cmd.exe /c echo \"123\"")
		executeCommandLine(winCurlCmd)
	} else {
		logDebug("gss.curl.dump", curlCommand)
		executeCommandLine(curlCommand, 2000)	
	}
end
*/

rule "User heating request change"
when
	Item UserHeatingRequest changed
then
	val userRequest = UserHeatingRequest.state
	
	if (userRequest == "AUTO") {
		
		// lookup persisted value of the CalendarHeatingRequest
		var String calendarHeatingState = CalendarHeatingRequest.state.toString()
		var String boilerState = BoilerHeatingMode.state.toString()
		
		logDebug("heating.auto.requested", "Compare calendar state and boiler's state: {} vs. {}", calendarHeatingState, boilerState)
		if (calendarHeatingState == "Uninitialized") {
			calendarHeatingState = "Off"
		}
		// compare current state and calendar's state
		if (calendarHeatingState != boilerState) {
		// if required, switch boiler to the requested heating mode
			sendCommand(BoilerHeatingMode, calendarHeatingState)
		}
		// if user requested AUTO himself - cancel timer/trigger
		if (heatingBackToAuto != null) {
			heatingBackToAuto.cancel()
			heatingBackToAuto = null
		}
		// update GUI
		postUpdate(BoilerCtrlMode, "Calendar")
		postUpdate(UserRequestExpires, expired)
	} else {
		postUpdate(BoilerCtrlMode, "Manual");
		
		if ( UserHeatingRequest.state == "Off" ) {
			
			sendCommand(BoilerHeatingMode, "Off")
			if (heatingBackToAuto != null) {
				heatingBackToAuto.cancel()
				heatingBackToAuto = null
			}
			// TODO send email reminder to switch boiler to calendar mode.
			logInfo("boiler.request.off", "Switching boiler off completely!!!")
			if (CalendarRequestPriority.state == OFF) {
				val String message = "Boiler is turned Off completely and won't be triggered by calendar. "
				//	+ "To activate the boiler remotely send a message to MQTT broker."
				// sendMail(to, subject, message)
			}
		} else {
			sendCommand(BoilerHeatingMode, "" + userRequest)
			// set a timer to switch back to calendar after timeout	
			var timeout = (UserRequestMaxDuration.state as DecimalType).intValue
			var endTime = now.plusHours(timeout)
			postUpdate(UserRequestExpires, new DateTimeType(endTime.toCalendar(new java.util.Locale("en"))))
			logDebug("schedule.fututre.event", "Back to calendar control on " + endTime)
			
			if (heatingBackToAuto == null) {
				heatingBackToAuto = createTimer(endTime) [|
					postUpdate(UserHeatingRequest, "AUTO")
				]
			} else {
				// reschedule does not work
				heatingBackToAuto.reschedule(endTime)
			}
		}
	} 
end


rule "Calendar heating event"
when
	Item CalendarHeatingRequest received command
then
	var cmd = receivedCommand
	// validate calendar heating request command
	if (cmd == "Off" || cmd == "LO_R" || cmd == "HI" || cmd == "LO_ALL") {
		if (BoilerCtrlMode.state == "Calendar") {
			// validate command
			sendCommand(BoilerHeatingMode, receivedCommand)
		
		} else if (CalendarRequestPriority.state == ON && BoilerHeatingMode.state == "Off") {
			logDebug("heating.calendar.takeover", "Received {} when calendar priority is ON and boiler is Off", cmd)
			// switch Manual to Calendar/AUTO
			sendCommand(UserHeatingRequest, "AUTO")
		} else {
			logInfo("calendar.request", "Boiler control mode: {}, heating mode: {}. Ignore command: {}", 
				BoilerCtrlMode.state, BoilerHeatingMode.state, cmd)
		}
	} else if (cmd != "CAL") {
		logInfo("calendar.event", "Unsupported calendar command event: {}", cmd)
	}
end

rule "Calendar control request" 
when
	Item CalendarHeatingRequest changed to CAL
then
	// switch back to calendar based heating schedule
	postUpdate(CalendarRequestPriority, ON)
	//restore the previous calendar request
	if (previousState == "CAL") {
		sendCommand(CalendarHeatingRequest, "Off")
	} else {
		sendCommand(CalendarHeatingRequest, previousState)
	}
	// send email
	// sendMail(to, "Brodok heating is back to calendar control", 
	// "Home heating system control mode is set to automatic (by calendar).")
end

rule "BoilerHeatingMode changed"
when
	Item BoilerHeatingMode changed
then
	val newState = BoilerHeatingMode.state
	logInfo("boiler.heating.mode", "Switch from {} to {}", previousState, newState)
	
	if (newState == "HI") {
		sendCommand(Heating_Boiler_HI, ON)
		sendCommand(Heating_Boiler_LO, OFF)
		postUpdate(WarmFloorValveHelper, OFF)
	
	} else if (newState == "LO_R") {
		sendCommand(Heating_Boiler_HI, OFF)
		sendCommand(Heating_Boiler_LO, ON)
		postUpdate(WarmFloorValveHelper, OFF)
		
	} else if (newState == "LO_ALL") {
		sendCommand(Heating_Boiler_HI, OFF)
		sendCommand(Heating_Boiler_LO, ON)
		
		if (previousState == "HI") {
			// delay opening warm floor valves until water cools down
			warmFloorTimer = null
			warmFloorTimer = createTimer(now.plusMinutes(5), [|
				WarmFloorValve.sendCommand(ON)
			])
			logDebug("boiler.heating.mode", "HI->LO_ALL 5 min. delay before opening warm floor valves")
		} else {
			WarmFloorValve.sendCommand(ON)
		}
	} else if (newState == "Off") {
		sendCommand(Heating_Boiler_HI, OFF)
		sendCommand(Heating_Boiler_LO, OFF)
		postUpdate(WarmFloorValveHelper, OFF)
		
	} else {
		logInfo("boiler.heating.mode", "Ignore command: " + newState)
	}
end

rule "Close warm floor valves correctly"
when
	Item WarmFloorValveHelper changed to OFF
then
	// check if timer exists to open valves in future
	if (warmFloorTimer != null) {
		warmFloorTimer.cancel()
		warmFloorTimer = null
	}
	// switch warm floor valves group OFF
	WarmFloorValve.sendCommand(OFF)
	postUpdate(WarmFloorValveHelper, ON)
end


rule "Average ambient temperature"
when
	Time cron "0 0 */2 * * ?"
then
	var ma = Temperature.averageSince(now.minusHours(24), "rrd4j")
	logInfo("temp.moving.average", "Moving average 24h: " + ma)
	postUpdate(ma24hRrdTemp, ma)
	
	ma = Temperature.averageSince(now.minusHours(48), "rrd4j")
	logInfo("temp.moving.average", "Moving average 48h: " + ma)
	postUpdate(ma48hRrdTemp, ma) 
end


/*
rule "Update daily average temperatures"
when
	Time cron noon
then
	if (c1 > 0) {
		val avg24h = t_fio24h / c1
		logInfo("temp.daily.average", 
			"For the last 24 hours: {} / {} = {}",
			t_fio24h, c1, avg24h)
		postUpdate(ma24hTemp, avg24h)
	}
	c1 = 0
	t_fio24h = 0
	
	if (c2 > 24) {
		// update 48h average
		val avg48h = t_fio48h / c2
		logInfo("temp.daily.average", 
			"For the last 24 hours: {} / {} = {}",
			t_fio48h, c2, avg48h)
		postUpdate(ma48hTemp, avg48h)
		
		c2 = 0
		t_fio48h = 0
	}
end

rule "Accumulate temperatures"
when
	Time cron "0 5 * * * ?" // every hour
	//Item Temperature received update
then
	var value = Temperature.state
	postUpdate(AmbientTempRrd, value)
	
	c1 = c1 + 1
	c2 = c2 + 1
	t_fio24h = t_fio24h + (value as DecimalType).doubleValue
	t_fio48h = t_fio48h + (value as DecimalType).doubleValue
	
	var String text = String::format("(step: %d, avg:%.2f)", c1, t_fio24h/c1)
	postUpdate(tempAccum24h, text)
	postUpdate(tempAccum48h, String::format("(step: %d, avg:%.2f)", c2, t_fio48h/c2))
	logInfo("daily.average", "accumulate value: {}", value)
end

*/

