import org.openhab.core.library.types.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*
import java.util.Date
import org.joda.time.*

var Number processUpdate = 0
//var String Boiler_PrevState
var String os_type = "win"
var Timer timer = null
var Timer heatingBackToAuto = null
var Timer warmFloorTimer = null

val DateTimeType expired = new DateTimeType()

/**
 * This rule switches off warm floor valves when boiler is about to switch to HI temp. mode
 */
 
/*
rule "Boiler HI mode"
 	when
 		Item Heating_Boiler_HI received command ON
 	then
 		WarmFloorValve.sendCommand(OFF)
end

rule "Boiler LO mode"
	when
 		Item Heating_Boiler_LO received command
 	then
 		if (receivedCommand == ON) {
 			// open warm floor manifold valves
 			if (Heating_Boiler_HI.state == OFF) {
 				
 				WarmFloorValve.sendCommand(ON)
	 		} else {
	 			logInfo("brodok.rules", "Cannot switch to LO mode, because boiler is running HI temperature mode.")
	 		}	
	 	} else {
	 		// close warm floor manifold valves
	 		WarmFloorValve.sendCommand(OFF)
	 	}
 end
*/
/*
 * Rule 1
 *
rule "Boiler Master mode change"
when
	Item Heating_Boiler_Mode received command
then
	var requested_mode = receivedCommand
	logInfo("brodok.rules", "Received command: " + requested_mode + ". previousState: " + Boiler_PrevState)
	
	// avoid processing duplicate commands
	if (requested_mode != Boiler_PrevState) {
	
		if (requested_mode == "Off") {
			sendCommand(Heating_Boiler_HI, OFF)
			sendCommand(Heating_Boiler_LO, OFF)	
				
		} else if (requested_mode == "HI") {
			sendCommand(Heating_Boiler_HI, ON)
			sendCommand(Heating_Boiler_LO, OFF)		
			
		} else if (requested_mode == "LO") {
			// when switching from HI to LO, give the temperature 5min to cool down before opening the valves 
			if (Boiler_PrevState == "HI") {
				logDebug("boiler.mode", "5 min. delay before opening warm floor valves")
			}
			sendCommand(Heating_Boiler_HI, OFF)
			sendCommand(Heating_Boiler_LO, ON)
			
		} else {
			logInfo("brodok.rules", "Ignore command: " + requested_mode)
		}
		
	}
end

rule "Boiler status update"
when
	Item Heating_Boiler_Mode changed
then
	var s = Heating_Boiler_Mode.state
	var msg = "Boiler status update attempt from [" + previousState + "] to [" + s + "]"
	logInfo("brodok.rules", msg)
	
	if ( !((s == "Off") || (s == "LO") || (s == "HI")) ) {
		// correct value for GUI
		Heating_Boiler_Mode.state = previousState		
	}
	// preserve value to filter out duplicate command (ON-ON or HI-HI) in upper rule 1
	Boiler_PrevState = Heating_Boiler_Mode.state.toString()
end
*/

rule "Calculate current heating power demand"
when
	Item HeatLoadFactor changed or
	Item HeatCompensation changed or
	Item Temperature changed
then
	var lf = (HeatLoadFactor.state as DecimalType).doubleValue
	var ambTemp 
	if (Temperature.state instanceof DecimalType) {
		ambTemp = (Temperature.state as DecimalType).doubleValue
	} else {
		ambTemp = 0
	}
	
	var roomTempAvg = (TempSensor.state as DecimalType).doubleValue
	var hc = (HeatCompensation.state as DecimalType).doubleValue
	var demand = (roomTempAvg - ambTemp) * lf - hc

	// Maximum required heat demand is 3kW (@-20C ambient temperature)
	if (demand > 3000) {
		demand = 3000
	}
	logDebug("brodok.rules", "calculated power demand kW: " + demand/1000)
	if (processUpdate == 1) {
		//postUpdate(HeatPowerDemand_Current, (demand/1000))	
		//postUpdate(PowerDemandLastUpdate, new DateTimeType())
		HeatPowerDemand_Current.postUpdate(demand/1000)
		PowerDemandLastUpdate.postUpdate(new DateTimeType())
	}
end

rule "Startup"
when
	System started
then
	
	postUpdate(TempSensor_Corridor, 20.0)
	postUpdate(TempSensor_Kitchen, 21.0)
	postUpdate(TempSensor_Bedroom, 19.0)
	
	AfterStartup.sendCommand(OFF)
	timer = createTimer(now.plusSeconds(20)) [|
		postUpdate(AfterStartup, ON)
	]
	//TempSensor.postUpdate(20.0)
	CalendarRequestPriority.postUpdate(ON)
	//BoilerCtrlMode.postUpdate("Calendar")
	
	//var os = java::lang::System::getProperty("os.name")
	//logDebug("homeHeating.os", os)
	
	logDebug("brodok.rules", "Init completed")
	processUpdate = 1
end	

/*
 * Let variables to get initial states from rrd
 */
rule "After System startup"
when
	Item AfterStartup changed from OFF to ON
then
	if (timer!=null) {
		timer.cancel
		timer = null
	}
	logDebug("heating.config", "Setting up default heating parameters")
	if (UserRequestMaxDuration.state == Uninitialized) {
		postUpdate(UserRequestMaxDuration, 4) // hours
	}
	
	// after system reboot boiler control mode is restored back to calendar
	postUpdate(UserHeatingRequest, "AUTO")
	var String message = "Boiler control mode set to Calendar after system reboot"
	logInfo("heating.control.mode", message)
	// sendMail(to, subject, message)
end

rule "Convert Atm. Pressure units"
when
	Item AtmPressure_mbar changed
then
	var mbar = (AtmPressure_mbar.state as DecimalType).doubleValue
	var mmHg = mbar * 0.75006375541921
	postUpdate(AtmPressure_mmHg, mmHg.intValue)
end

rule "Heating Power demand persist to Google"
when
	//Time is noon // recalculate power demand once a day
	//Time cron "0 */6 * * * ?" // every 5 min.
	Item LO_HI_Ratio changed
then
	// TODO calculate daily average ambient temp for the last 24h.
	
	var Number dailyAvgAmbientTemp = 6.7
	var average = Temperature.averageSince(now.minusMinutes(30), "rrd4j")
	if (average instanceof DecimalType) {
		dailyAvgAmbientTemp = (average as DecimalType).doubleValue
	}
	logDebug("gss.daily.avg.temp", "" + dailyAvgAmbientTemp)
	
	var roomTempAvg = 16.0
	if (TempSensor.state instanceof DecimalType) {
		roomTempAvg = (TempSensor.state as DecimalType).doubleValue	
	}
	logDebug("gss.room.temp", "" + roomTempAvg)
	
	var hc = (HeatCompensation.state as DecimalType).intValue
	var lf = (HeatLoadFactor.state as DecimalType).intValue
	
	var demand = (roomTempAvg - dailyAvgAmbientTemp) * lf - hc

	// Maximum required heat demand is 3kW (@-20C ambient temperature)
	if (demand > 3000) {
		demand = 3000
	}
	demand = demand / 1000 // in kW
	logDebug("gss.daily.power.demand", demand + " kW")
	postUpdate(HeatPowerDemand_DailyAvg, demand)
	
	var Number maxBoilerPower = (ActiveBoilerHeatingElements.state as DecimalType).intValue
	// number of active heating elements of the boiler
	logDebug("gss.maxBoilerPower", maxBoilerPower + " kW");
	
	logDebug("gss.url", "" + GoogleScriptURL.state)
	
	var Number lhRatio = (LO_HI_Ratio.state as DecimalType).intValue
	
	var curlCommand = String::format(
		// windows specific call
		//"cmd.exe /c curl -k \"%1$s?Date=%%date%%&Time=%%time%%" + // 1
		// linux specific call
		"/usr/bin/curl -k \"%1$s?Date=%9$tF&Time=%9$tR" + //1
		"&RoomTemp=%2$.2f" + //2
		"&AmbientTemp=%3$.2f" + //3
		"&HeatLoadFactor=%4$d" + //4
		"&HeatCompensation_W=%5$d" + //5
		"&boilerMaxPower_kW=%6$d" + //6
		"&dailyAvgPowerDemand_kW=%7$.3f" + //7
		"&LO_HI_Ratio=%8$d\"", //8 
		GoogleScriptURL.state, roomTempAvg, dailyAvgAmbientTemp, lf, hc, maxBoilerPower, demand, lhRatio, new Date()
		)
	if (os_type == "win") {
		executeCommandLine("cmd.exe /c echo \"123\"")
	} else {
		executeCommandLine(curlCommand, 2000)	
	}
end

rule "User heating request change"
when
	Item UserHeatingRequest changed
then
	val userRequest = UserHeatingRequest.state
	
	if (userRequest == "AUTO") {
		
		// lookup persisted value of the CalendarHeatingRequest
		var String calendarHeatingState = CalendarHeatingRequest.state.toString()
		var String boilerState = BoilerHeatingMode.state.toString()
		
		logDebug("heating.auto.requested", "Compare calendar state and boiler's state: {} vs. {}", calendarHeatingState, boilerState)
		if (calendarHeatingState == "Uninitialized") {
			calendarHeatingState = "Off"
		}
		// compare current state and calendar's state
		if (calendarHeatingState != boilerState) {
		// if required, switch boiler to the requested heating mode
			sendCommand(BoilerHeatingMode, calendarHeatingState)
		}
		// if user requested AUTO himself - cancel timer/trigger
		if (heatingBackToAuto != null) {
			heatingBackToAuto.cancel()
			heatingBackToAuto = null
		}
		// update GUI
		postUpdate(BoilerCtrlMode, "Calendar")
		postUpdate(UserRequestExpires, expired)
	} else {
		postUpdate(BoilerCtrlMode, "Manual");
		
		if ( UserHeatingRequest.state == "Off" ) {
			
			sendCommand(BoilerHeatingMode, "Off")
			if (heatingBackToAuto != null) {
				heatingBackToAuto.cancel()
				heatingBackToAuto = null
			}
			// TODO send email reminder to switch boiler to calendar mode.
			logInfo("boiler.request.off", "Switching boiler off completely!!!")
			if (CalendarRequestPriority.state == OFF) {
				val String message = "Boiler is turned Off completely and won't be triggered by calendar. "
				//	+ "To activate the boiler remotely send a message to MQTT broker."
				// sendMail(to, subject, message)
			}
		} else {
			sendCommand(BoilerHeatingMode, "" + userRequest)
			// set a timer to switch back to calendar after timeout	
			var timeout = (UserRequestMaxDuration.state as DecimalType).intValue
			var endTime = now.plusHours(timeout)
			postUpdate(UserRequestExpires, new DateTimeType(endTime.toCalendar(new java.util.Locale("en"))))
			logDebug("schedule.fututre.event", "Back to calendar control on " + endTime)
			
			if (heatingBackToAuto == null) {
				heatingBackToAuto = createTimer(endTime) [|
					postUpdate(UserHeatingRequest, "AUTO")
				]
			} else {
				// reschedule does not work
				heatingBackToAuto.reschedule(endTime)
			}
		}
	} 
end

rule "Heating control back to calendar"
when
	Item BoilerCtrlMode changed from "Manual" to "Calendar"
then
	logDebug("heating.man2calendar", "confirmed")
end

rule "Calendar heating event"
when
	Item CalendarHeatingRequest received command
then
	var cmd = receivedCommand
	// validate calendar heating request command
	if (cmd == "Off" || cmd == "LO_R" || cmd == "HI" || cmd == "LO_ALL") {
		if (BoilerCtrlMode.state == "Calendar") {
			// validate command
			sendCommand(BoilerHeatingMode, receivedCommand)
		
		} else if (CalendarRequestPriority.state == ON) {
			logDebug("heating.calendar.redirect", "Recieved {} when priority is ON", receivedCommand)
			// switch Manual to Calendar/AUTO
			sendCommand(UserHeatingRequest, "AUTO")
		} else {
			logInfo("calendar.request", "Calendar priority is OFF. Ignore command: " + cmd)
		}
	} else if (cmd != "CAL") {
		logInfo("calendar.event", "Unsupported calendar command event: {}", cmd)
	}
end

rule "Calendar control request" 
when
	Item CalendarHeatingRequest changed to CAL
then
	// switch back to calendar based heating schedule
	postUpdate(CalendarRequestPriority, ON)
	//restore the previous calendar request
	if (previousState == "CAL") {
		sendCommand(CalendarHeatingRequest, "Off")
	} else {
		sendCommand(CalendarHeatingRequest, previousState)
	}
	// send email
	// sendMail(to, "Brodok heating is back to calendar control", 
	// "Home heating system control mode is set to automatic (by calendar).")
end

rule "BoilerHeatingMode changed"
when
	Item BoilerHeatingMode changed
then
	val newState = BoilerHeatingMode.state
	logInfo("boiler.heating.mode", "Switch from {} to {}", previousState, newState)
	
	if (newState == "HI") {
		sendCommand(Heating_Boiler_HI, ON)
		sendCommand(Heating_Boiler_LO, OFF)
		postUpdate(WarmFloorValveHelper, OFF)
	
	} else if (newState == "LO_R") {
		sendCommand(Heating_Boiler_HI, OFF)
		sendCommand(Heating_Boiler_LO, ON)
		postUpdate(WarmFloorValveHelper, OFF)
		
	} else if (newState == "LO_ALL") {
		sendCommand(Heating_Boiler_HI, OFF)
		sendCommand(Heating_Boiler_LO, ON)
		
		if (previousState == "HI") {
			// delay opening warm floor valves until water cools down
			warmFloorTimer = null
			warmFloorTimer = createTimer(now.plusMinutes(5), [|
				WarmFloorValve.sendCommand(ON)
			])
			logDebug("boiler.heating.mode", "HI->LO_ALL 5 min. delay before opening warm floor valves")
		} else {
			WarmFloorValve.sendCommand(ON)
		}
	} else if (newState == "Off") {
		sendCommand(Heating_Boiler_HI, OFF)
		sendCommand(Heating_Boiler_LO, OFF)
		postUpdate(WarmFloorValveHelper, OFF)
		
	} else {
		logInfo("boiler.heating.mode", "Ignore command: " + newState)
	}
end

rule "Close warm floor valves correctly"
when
	Item WarmFloorValveHelper changed to OFF
then
	// check if timer exists to open valves in future
	if (warmFloorTimer != null) {
		warmFloorTimer.cancel()
		warmFloorTimer = null
	}
	// switch warm floor valves group OFF
	WarmFloorValve.sendCommand(OFF)
	postUpdate(WarmFloorValveHelper, ON)
end
