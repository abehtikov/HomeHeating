import org.openhab.core.library.types.*
import org.openhab.core.persistence.*
import org.openhab.model.script.actions.*
import java.util.Date
import org.joda.time.*
import java.lang.Math
import org.joda.time.Minutes

val int collectorAzimuthAngle = 234


rule "Convert Atm. Pressure units"
when
	Item AtmPressure_mbar changed
then
	var mbar = (AtmPressure_mbar.state as DecimalType).doubleValue
	var mmHg = mbar * 0.75006375541921
	postUpdate(AtmPressure_mmHg, mmHg.intValue)
end


rule "Sun position update"
when
	Item SunAzimuth received update
then
	var azimuth = (SunAzimuth.state as DecimalType).intValue
	var elevation = (SunElevation.state as DecimalType).doubleValue
	
	val minAngle = collectorAzimuthAngle - 90
	val maxAngle = collectorAzimuthAngle + 90
	
	if (elevation < 0) {
		postUpdate(CollectorInShadow, ON)
	}
	// horizontal shadow criteria
	else if (azimuth > minAngle && azimuth < maxAngle) {
		postUpdate(CollectorInShadow, OFF)
		var int angleDiff = Math::abs(azimuth - collectorAzimuthAngle)
		postUpdate(SunbeamAngleToFacade, 90 - angleDiff)
	} else {
		postUpdate(CollectorInShadow, ON)
	}
end


rule "Update ThingSpeak Solar temperatures"
when
	Time cron "15 * * * * ?"
then
	val field1 = (CollectorTemp.state as DecimalType).doubleValue
	val field2 = (ReturnTemp.state as DecimalType).doubleValue
	var field3 = 0
	if (SolarPumpSw.state == ON) { field3 = 1 }
	val field4 = (rtFiltDeltaT.state as DecimalType).doubleValue
	// flowRate
	val f5 = (pFlowRate.state as DecimalType).doubleValue
	val f6 = (LatestDhwReturnTemp.state as DecimalType).doubleValue
	
	//val api_key = "4ZYKQYVC6E4WYELM"
	var url = String::format("https://api.thingspeak.com/update?"
		+ "api_key=%7$s"
		+ "&field1=%1$.2f"
		+ "&field2=%2$.2f"
		+ "&field3=%3$d"
		+ "&field4=%4$.2f"
		+ "&field5=%5$.1f"
		+ "&field6=%6$.1f",
		field1, field2, field3, field4, f5, f6, pThingSpeakApiKeySolar.state
	)
	logDebug("solar", "Update thingspeak channel 61471: " + url)
	sendHttpGetRequest(url)
end	

/*
 * Update thingspeak channel
 */
rule "Update ThingSpeak Brodok_heating channel"
when
	Item Pi_Temperature received update
then
	val value = (Pi_Temperature.state as DecimalType).doubleValue
	//val api_key = "Z2YLVVS4CRNV2AVX"
	var url = String::format("https://api.thingspeak.com/update?api_key=%2$s&field1=%1$.2f",
		value, pThingSpeakApiKeyHeating.state
	)
	logDebug("brodok.rules", "Update thingspeak url: " + url)
	sendHttpGetRequest(url)
end

/*
 * GUI solar controller params
 */
rule "Update power density" // Удельная мощность теплоносителя Ватт/градус К
when
	Item pHeatingCapacity received update or
	Item pFlowRate received update
then
	var double value = 60.0 //by default 60 W/deg C
	
	if (pHeatingCapacity.state instanceof DecimalType &&
		pFlowRate.state instanceof DecimalType) {
		
		val capacity = (pHeatingCapacity.state as DecimalType).doubleValue
		val flowRate = (pFlowRate.state as DecimalType).doubleValue
		
		if (capacity > 3500.0 && capacity < 4200.0) {
			value = (capacity * flowRate / 3600.0).doubleValue
			logInfo("solar", "Power density: {} W/deg C, Flow rate: {} l/h", value, flowRate)
		} else {
			logWarn("solar", "Invalid heating capacity value: {}", capacity)
		}
	}
	
	postUpdate(rtPowerDensity, value)
end

rule "Water or glycol"
when
	Item pSolarFluidType changed
then
	val type = pSolarFluidType.state
	
	if (type == 1) {
		postUpdate(pHeatingCapacity, 3800)
		postUpdate(SolarFluid, "Glycol")
	} else {
		postUpdate(pHeatingCapacity, 4187)
		postUpdate(SolarFluid, "Water")
		postUpdate(tnIceProtectionEnabled, ON)
	}
end

/*
 * Если не в отпуске
 * и (а) коллектор находится в тени или
 * (б) нет солнца (пасмурно)
 * 
 * Само-остывание бойлера 1 кВт-ч/сутки + 6 кВт-ч/сутки потребление ГВ
 * 
 * Бойлер 120 лтр
 */
rule "DHW Storage self discharge" // 
when
	Time cron "0 */20 * * * ?" // every 20 min
then
	val oldValue = (LatestDhwReturnTemp.state as DecimalType).doubleValue
	var int k = 30 // 0.03 в обычное время
	val double minTemp = 18.0
	
	// Коллектор в тени и насос выключен
	if (/*CollectorInShadow.state == ON &&*/ SolarPumpSw.state == OFF) {
		
		val delta = oldValue - minTemp
		if (HolidayModeSw.state == ON) { 
			k = 7 // 0.007 - нет водоразбора (в отпуске) = 0.021 * delta / per hour
		} 
		
		if (oldValue > 20.0) {
			
			val int vv = (k * delta).intValue
			val double drop = vv / 1000.0
			// T бойлера не может упасть ниже 10 градусов (зимой - ниже 5)
			logDebug("solar", "DHW storage T {} down by {} C. Holiday mode: {}",
				oldValue, drop, HolidayModeSw.state
			)
			postUpdate(LatestDhwReturnTemp, oldValue - drop)		
		}
	}
end


/*
rule "Weather forecast next day"
when 
	Item Clouds received update or
	Item Condition received update
then
	var cloudsPercent = (Clouds.state as DecimalType).intValue

	if (Condition.state == "clear sky") {
		postUpdate(SunnyTomorrow, ON)
	} else if (cloudsPercent > 60) {
		postUpdate(SunnyTomorrow, OFF)
	} else {
		postUpdate(SunnyTomorrow, ON)
	}
end
*/

rule "OpenWeatherMap conditions tomorrow"
when 
	Item Condition_ID received update
then
	// rule is valid for OWM provider only! 
	val owm_id = (Condition_ID.state as DecimalType)
	if (owm_id == 800 ||
		owm_id == 801 ||
		owm_id == 802 ||
		owm_id == 904
	) {
		postUpdate(SunnyTomorrow, ON)
	} else {
		postUpdate(SunnyTomorrow, OFF)
	}
end


rule "Check OWM forecast"
when 
	Time cron "55 2 6 * * ?" // 6:02:55 am every day
	or Item pSolarFluidType changed
	//or Item AfterStartup changed to ON
then
	val fmt = "http://api.openweathermap.org/data/2.5/forecast/city?id=%1$s&APPID=%2$s&mode=xml&cnt=8"
	var url = String::format(fmt, pOwmCityId.state, pOwmApiKey.state)
	logInfo("solar", "Requesting OpenWeatherMap forecast for city {}", pOwmCityId.state)
	var String xml = sendHttpGetRequest(url)
	
	/*
	 * <time from="2016-06-09T15:00:00" to="2016-06-09T18:00:00">
		<symbol number="802" name="scattered clouds" var="03d"/>
		<precipitation/>
		<windDirection deg="307.002" code="NW" name="Northwest"/>
		<windSpeed mps="3.42" name="Gentle Breeze"/>
		<temperature unit="celsius" value="13.48" min="13.08" max="13.48"/>
		<pressure unit="hPa" value="996.03"/>
		<humidity value="60" unit="%"/>
		<clouds value="scattered clouds" all="44" unit="%"/>
	   </time>
	 */
	var offset = 3
	var String rootNode = "/weatherdata/forecast/time[" + offset + "]"
	logDebug("solar", "OWM forecast:\n{}", xml)
	// assuming the query is executed at 6 am: 1 --> 6am - 9am, 2 --> 9am - 12:00 forecast
	// 3 --> 12:00 - 15:00
	// 4 --> 15:00 - 18:00
	var expr1 = "number(" + rootNode + "/symbol/@number)"
	var condition_id = transform("XPATH", expr1, xml)
	
	var condition = transform("XPATH", "string(" + rootNode + "/symbol/@name)", xml)
	var clouds = transform("XPATH", "number(" + rootNode + "/clouds/@all)", xml)
	
	logInfo("solar", "Today 12:00 - 3pm : {}, clouds {}%", condition, clouds)
	var t1 = transform("XPATH", "string(/weatherdata/forecast/time[3]/@from)", xml)
	var t2 = transform("XPATH", "string(/weatherdata/forecast/time[3]/@to)", xml)
	
	//t1 = transform("REGEX", "/^T\\(d{2}:d{2})", t1)
	
	postUpdate(Condition_ID, condition_id)
	postUpdate(Clouds, clouds)
	postUpdate(Condition, condition)
end



